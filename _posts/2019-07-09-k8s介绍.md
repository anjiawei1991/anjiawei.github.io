---
layout: post
author: 安佳玮
---

本篇文章旨在介绍 Kubernetes 的诞生背景，以及 Kubernetes 的集群架构和工作模式，旨在为读者提供一个基础的对 Kubernetes 的认知，尽量避免了一些复杂或者晦涩的概念。不涉及具体的 Kubernetes 的使用方法、环境搭建等。

## 微服务

微服务是相对于单体应用而言的，它主张将大的单体的应用按照业务划分成小的、独立的服务单元，服务之间通过 API 相互交互，彼此协作为用户提供服务。

![微服务与单体服务](/assets/blog/micro.png?raw=true)

微服务带来了很多好处：

1. 改善上线困难的问题。单体应用中，由于所有功能都在同一个进程中，所以在开发、部署、管理的时候必须以同一个实体进行。再小的修改，都需要重新部署整个应用。但是微服务中，每个服务只负责一个或少量密切相关的业务，所以一个功能的修改，只需要重新发布对应的服务。
2. 改善扩容困难的问题。随着业务规模扩大，需要对服务进行持续扩容。扩容可以是提高机器配置，比如增加额外的 CPU、内存或者磁盘等系统资源，这种扩容方式叫做垂直扩展。垂直扩展对单体应用或者微服务都是适用的，但是它的成本会越来越高，最终你可能需要一台超级计算机。扩容也可以是部署多个进程，这种方式叫做水平扩展，这种扩容方式需要的成本比垂直扩展低得多，因为不同的进程可以部署在不同的机器上，提高机器配置变成了提高机器数量。但是对于单体应用，由于所有功能都在同一个进程中，如果有任何一个模块不能水平扩容，那么整个应用就无法水平扩容，除非想办法把它拆开。而微服务中，因为功能原本就是独立的，所以可以单独针对某个或者某些服务来做水平扩容。
3. 提高容错性。单体应用一个功能的内存泄漏可能影响这个进程。但是微服务一个功能的内存泄露只会影响自己。
4. 新技术的应用。微服务中可以单独对某个服务采用新技术，而不影响其它服务。
5. 功能独立开发。微服务中每个功能都可以使用不同的语言、不同的技术来实现。

------

然而，微服务也有缺点，最大的缺陷就是部署困难问题：

1. 配置复杂，当服务数量增加时，运维需要为每个服务的每个进程进行单独配置，稍有差错，就会在部署阶段暴露出问题。
2. 资源利用问题，不同的服务可能需要不同的资源（CPU、内存等），运维需要决定在哪些系统上部署哪些服务，以达到最佳组合。
3. 依赖问题，因为不同的服务可能采用不同的依赖库，甚至不同的服务采用不同的依赖版本，那生产机器究竟要安装什么版本的依赖库呢？

为了解决这些问题，容器技术(Docker) 和 Kubernetes 诞生了！

## 容器

容器是一个隔离技术，它允许你在同一台主机上运行多个独立的进程，不同的进程拥有隔离的网络、进程空间、用户空间、文件系统等。容器的隔离技术是用名命名空间来实现的。进程只能看到同一个命名空间下的其它进程、网络接口、文件系统等。

容器也用来限制进程的可用资源（CPU、内存、网络带宽等），这是通过 Linux 内核的 cgroups 来实现的，它可以用来限制一个进程或一组进程的资源使用。在这种限制下，进程不能过分使用其它进程保留的资源。

虚拟机也能实现隔离，他们的实现方式是不同的。容器更加轻量，它是直接在宿主机上运行用户的进程，不需要安装一个新的操作系统增加额外的开销。相比之下，虚拟机的主要好处就是提供完全隔离的环境。

![容器和虚拟机比较](/assets/blog/container.png?raw=true)

[Docker](https://www.docker.com) 是一个打包、分发和运行应用程序的容器平台。在当前的生态环境下，谈论容器技术基本就是在谈论 Docker 了。Docker 由主要由以下概念组成：

1. 镜像。Docker 将应用所需的所有一切打包到一个独立的可移植的包中，这个包可以在任何其它安装了 Docker 的机器上运行。镜像包括了应用的文件系统，启动命令以及依赖文件等。
2. 镜像仓库。Docker 镜像仓库用于存放 Docker 镜像。可以在构建镜像的机器上运行你的镜像，也可以把镜像上传到镜像仓库，然后在其它机器上拉取并执行。 Docker 官方提供了一个[镜像仓库](https://hub.docker.com)，所有人可以往上面提交自己的镜像。官方的仓库上有很多著名的第三方镜像，包括 mysql、redis、nginx、php、consul、python 等。很多时候，我们可以很方便的使用这些官方镜像来构建应用。如果需要，你也可以使用官方的[镜像仓库镜像](https://hub.docker.com/_/registry)搭建你自己的镜像仓库。
3. 容器。Docker 容器可以理解为运行中的镜像。它是一个运行在 Docker 主机上的进程，但它和主机，以及所有运行在主机上的其他进程都是隔离的。这个进程也是资源受限的，意味着它只能访问和使用分配给它的资源（CPU、内存等）

下图展示了这 3 者之间的关系：

![Docker 镜像、镜像仓库和容器](/assets/blog/docker.png?raw=true)

## Kubernetes

Kubernetes 是谷歌开发的用于简化部署和管理容器的开源系统。Kubernetes 通常简称为 k8s（中间的 8 是指 K 和 s 中间的 8 个字母，而不是我们通常认为的发音）。

相比自己手动部署容器，Kubernetes 解决了下面这些问题：

* 简化应用部署。Kubernetes 将其所有工作节点公开为一个部署平台，因此应用程序开发人员可以自己开始部署应用程序，不需要了解组成集群的服务器节点。
* 更好的硬件资源利用。你只需要提供足够多的硬件资源，然后告诉 Kubernetes 你的每个容器需要多少资源（CPU、网络、磁盘等），然后 Kubernetes 会选择自动组合你的容器放到合适的机器上运行。
* 健康检查和自修复。当你的容器发生故障而异常退出了，或者你的某个服务器断电了，Kubernetes 会将你的容器再次启动。
* 自动扩容。你只需要告诉 Kubernetes 每个容器需要启动的示例数量，然后 Kubernetes 会帮你一直维护这么多数量的实例。

### Kubernetes 集群架构

一个 Kubernetes 集群中由很多节点组成，这些节点分为两种类型：

1. 主节点，它为集群提供控制面板。功能包括调度、提供集群 API 服务、检测并响应集群事件（比如当用户期望的服务实例数量和当前实际实例数量不一致时，它启动服务来达成期望状态）等。它包括以下组件：

* API 服务器，用于提供 API 服务，相当于控制面板的前端。 
* etcd， 提供 KV 服务，用于集群数据的存储
* 调度器，用于调度和启动服务实例
* 控制器管理器，又分为节点控制器（用于监听和响应节点下线事件）、副本控制器（用于维持服务的数量与期望数量一致）等等

2. 工作节点，它运行集群的实际服务。它包括以下组件：

* kubelet，它检测运行在工作节点上的服务的健康状态，并与 API 服务器通信
* kube-proxy，它负责网络代理，通过维护一组网络规则提供服务抽象。
* 容器运行时库，这通常指 Docker(也可以是其它容器类型)。

![k8s 节点](/assets/blog/k8s-nodes.png?raw=true)

### Kubernetes 工作模式

Kubernetes 基于这样一种模式来达成它的目的： 你通过 API 告诉 Kubernetes 你所期望的状态(比如需要启动哪些服务、服务的容器镜像、每个服务启动多少个等)，Kubernetes 集群中的各个节点相互配合来达成你所期望的状态。如下图所示：

![k8s 工作模式](/assets/blog/k8s-work-model.png?raw=true)

下面介绍了一个使用 Kubernetes 的基础流程：

1. 我们在本地机器上开发自己的服务，然后将服务以及它们的依赖文件打包成 Docker 镜像，并将镜像推送到镜像仓库（可以是 Docker 官方的镜像仓库，也可以是我们自己搭建的镜像仓库）
2. 通过 yaml、json 等格式编写描述文件，该描述包括诸如各个服务组件的容器镜像、服务之间如何关联，哪些服务需要在同一个节点上和哪些服务不需要在同一个节点上运行等信息。
3. 我们将描述文件通过 Kubernetes 提供的工具或者接口发布到 Kubernetes API 服务器
4. Kubernetes 根据描述文件以及当前的工作节点资源使用状态，通知对应的工作节点拉取并运行容器镜像以达成我们期望的状态。
5. Kubernetes 会持续检测实例是否正常运行，如果某个实例停止工作了，就会自动重启它。Kubernetes 也会检测所有的工作节点状态，如果发现某个工作节点无法访问了，会为故障节点上所有的容器选择新的工作节点运行
6. 当我们需要更新时，比如发布新的版本或者希望增加实例数量，那么将新的描述文件再次提交给 Kubernetes，Kubernetes 的各个节点又会相互配合来达成我们的期望状态。


![k8s 工作模式](/assets/blog/k8s-work-model-detail.png?raw=true)










